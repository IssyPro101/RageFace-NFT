{"ast":null,"code":"'use strict';\n\nconst _require = require('multiformats/cid'),\n      CID = _require.CID;\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\n\n\nconst resolve = async function* (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await getBlock(cid, options);\n    return codec.decode(block);\n  };\n\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid);\n  let lastCid = cid;\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    };\n  } // End iteration if there isn't a CID to follow any more\n\n\n  while (parts.length) {\n    const key = parts.shift();\n\n    if (!key) {\n      throw errCode(new Error(\"Could not resolve path \\\"\".concat(path, \"\\\"\")), 'ERR_INVALID_PATH');\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode(new Error(\"no link named \\\"\".concat(key, \"\\\" under \").concat(lastCid)), 'ERR_NO_LINK');\n    }\n\n    const cid = CID.asCID(value);\n\n    if (cid) {\n      lastCid = cid;\n      value = await load(value);\n    }\n  }\n};\n\nmodule.exports = resolve;","map":null,"metadata":{},"sourceType":"script"}
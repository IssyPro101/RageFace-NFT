{"ast":null,"code":"'use strict';\n\nconst _require = require('multiformats/cid'),\n      CID = _require.CID;\n\nconst Client = require('../../lib/core');\n\nconst Service = require('./service');\n\nconst toUrlSearchParams = require('../../lib/to-url-search-params');\n/**\n * @typedef {import('../../types').Options} Options\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Pin} Pin\n * @typedef {import('ipfs-core-types/src/pin/remote').AddOptions} AddOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').Query} Query\n * @typedef {import('ipfs-core-types/src/pin/remote').Status} Status\n * @typedef {import('../../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pin/remote').API<HTTPClientExtraOptions>} RemotePiningAPI\n */\n\n\nclass Remote {\n  /**\n   * @param {Options} options\n   */\n  constructor(options) {\n    this.client = new Client(options);\n    /** @readonly */\n\n    this.service = new Service(options);\n  }\n\n}\n/**\n * @type {RemotePiningAPI[\"add\"]}\n */\n\n\nRemote.prototype.add = async function add(cid, {\n  timeout,\n  signal,\n  headers,\n  ...query\n}) {\n  const response = await this.client.post('pin/remote/add', {\n    timeout,\n    signal,\n    headers,\n    searchParams: encodeAddParams({\n      cid,\n      ...query\n    })\n  });\n  return decodePin((await response.json()));\n};\n/**\n * @type {RemotePiningAPI[\"ls\"]}\n */\n\n\nRemote.prototype.ls = async function* ls({\n  timeout,\n  signal,\n  headers,\n  ...query\n}) {\n  const response = await this.client.post('pin/remote/ls', {\n    timeout,\n    signal,\n    headers,\n    searchParams: encodeQuery(query)\n  });\n\n  for await (const pin of response.ndjson()) {\n    yield decodePin(pin);\n  }\n};\n/**\n * @type {RemotePiningAPI[\"rm\"]}\n */\n\n\nRemote.prototype.rm = async function rm({\n  timeout,\n  signal,\n  headers,\n  ...query\n}) {\n  await this.client.post('pin/remote/rm', {\n    timeout,\n    signal,\n    headers,\n    searchParams: encodeQuery({ ...query,\n      all: false\n    })\n  });\n};\n/**\n * @type {RemotePiningAPI[\"rmAll\"]}\n */\n\n\nRemote.prototype.rmAll = async function ({\n  timeout,\n  signal,\n  headers,\n  ...query\n}) {\n  await this.client.post('pin/remote/rm', {\n    timeout,\n    signal,\n    headers,\n    searchParams: encodeQuery({ ...query,\n      all: true\n    })\n  });\n};\n/**\n * @param {Object} json\n * @param {string} json.Name\n * @param {string} json.Cid\n * @param {Status} json.Status\n * @returns {Pin}\n */\n\n\nconst decodePin = ({\n  Name: name,\n  Status: status,\n  Cid: cid\n}) => {\n  return {\n    cid: CID.parse(cid),\n    name,\n    status\n  };\n};\n/**\n * @param {any} service\n * @returns {string}\n */\n\n\nconst encodeService = service => {\n  if (typeof service === 'string' && service !== '') {\n    return service;\n  } else {\n    throw new TypeError('service name must be passed');\n  }\n};\n/**\n * @param {any} cid\n * @returns {string}\n */\n\n\nconst encodeCID = cid => {\n  if (CID.asCID(cid)) {\n    return cid.toString();\n  } else {\n    throw new TypeError(\"CID instance expected instead of \".concat(typeof cid));\n  }\n};\n/**\n * @param {Query & { all?: boolean }} query\n * @returns {URLSearchParams}\n */\n\n\nconst encodeQuery = ({\n  service,\n  cid,\n  name,\n  status,\n  all\n}) => {\n  const query = toUrlSearchParams({\n    service: encodeService(service),\n    name,\n    force: all ? true : undefined\n  });\n\n  if (cid) {\n    for (const value of cid) {\n      query.append('cid', encodeCID(value));\n    }\n  }\n\n  if (status) {\n    for (const value of status) {\n      query.append('status', value);\n    }\n  }\n\n  return query;\n};\n/**\n * @param {AddOptions & {cid:CID}} options\n * @returns {URLSearchParams}\n */\n\n\nconst encodeAddParams = ({\n  cid,\n  service,\n  background,\n  name,\n  origins\n}) => {\n  const params = toUrlSearchParams({\n    arg: encodeCID(cid),\n    service: encodeService(service),\n    name,\n    background: background ? true : undefined\n  });\n\n  if (origins) {\n    for (const origin of origins) {\n      params.append('origin', origin.toString());\n    }\n  }\n\n  return params;\n};\n\nmodule.exports = Remote;","map":null,"metadata":{},"sourceType":"script"}